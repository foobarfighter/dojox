<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
	<title></title>
	<script type="text/javascript" src="../../../../dojo/dojo.js"
	    djConfig="isDebug: true"></script>
	<script type="text/javascript">
		dojo.require("doh.runner");
		dojo.require("dojox.rails");
		dojo.require("dojox.rails.decorators.Request");

        var request = null;
        var drd = dojox.rails.decorators;

        // FIXME: remove dojo.connect.  This function is broken... kinda.  dojo.connect does not behave how I thought it did.
        function mock(connectScope, func){
            var scope = scope || dojo.global;

            if (!scope[func].__mockHint) { scope[func].__mockHint = (scope.declaredClass || scope) + ": " + func }
            dojo.connect(connectScope, func, null, function() {
                if (!scope[func].__mockCalled) { scope[func].__mockCalled = 0 }

                scope[func].__mockCalled++;
            });
        }

        function assertMockCalled(t, mockedFunc, times) {
            var failPrefix = mockedFunc.__mockHint + ": ";
            var called = mockedFunc.__mockCalled;
            if (times == 0){
                t.t(called == null, failPrefix + ": was called " + called + " times but should not have been called");
            }else{
                times = times || 1;
                t.t(called != null, failPrefix + ": was not called");
                t.is(called, times, failPrefix + ": expected to be called " + times + " times but was called " + called + " times");
            }
        }

        doh.register("dojox.rails.tests.decorators.Request", [
            {
                name: "Callback parsing",
                runTest: function(t) {
                    var request = new drd.Request("test_successful_callback_parse");

                    var assertCallbackConnection = function(cbName){
                        var cbMapping = "on" + dojox.rails.camelize(cbName);
                        var found = false;
                        dojo.forEach(request._connects, function(connect){
                            if (connect[0] == request && connect[1] == cbMapping){ found = true }
                        });
                        t.t(found, "'" + cbName + "' callback was not connected");
                    }

                    var expectedMappedCallbacks = ["complete", "interactive", "loaded", "loading"];
                    dojo.forEach(expectedMappedCallbacks, assertCallbackConnection);

                    try{
                        new drd.Request("test_unsupported_callback_parse");
                        t.t(false, "Request decorator should not have been instantiated with an unsupported callback");
                    }catch(e){
                        t.is("'unsupported' is an unsupported callback", e.message);
                    }
                }
            },
            {
                name: "Request method parsing",
                runTest: function(t) {
                    t.is("get", (new drd.Request("test_method_default")).getMethod());
                    t.is("put", (new drd.Request("test_method_with_data_attribute")).getMethod());
                    t.is("post", (new drd.Request("test_method_with_method_attribute")).getMethod());
                    t.is("delete", (new drd.Request("test_method_with_data_and_method_attribute")).getMethod());
                }
            },
            {
                name: "Request argument parsing",
                runTest: function(t) {

                }
            },
            {
                name: "Request callback execution",
                setUp: function() {
                    // FIXME: mocking here is broken
                    mock(null, "execSuccessCallback");
                    mock(null, "execFailureCallback");
                    mock(null, "execCompleteCallback");
                    mock(null, "execInteractiveCallback");
                    mock(null, "execLoadedCallback");
                    mock(null, "execLoadingCallback");

                    request = new drd.Request("test_callback_execution");
                },
                tearDown: function() {
                    request = null;
                },
                runTest: function(t) {
                    request.onSuccess();
                    assertMockCalled(t, dojo.global.execSuccessCallback);

                    request.onFailure();
                    assertMockCalled(t, dojo.global.execFailureCallback);

                    request.onComplete();
                    assertMockCalled(t, dojo.global.execCompleteCallback);

                    request.onInteractive();
                    assertMockCalled(t, dojo.global.execInteractiveCallback);

                    request.onLoaded();
                    assertMockCalled(t, dojo.global.execLoadedCallback);

                    request.onLoading();
                    assertMockCalled(t, dojo.global.execLoadingCallback);
                }
            }
        ]);

        function loadCb(request) {}
        function errorCb(request) {}

        function execSuccessCallback() {}
        function execFailureCallback() {}
        function execCompleteCallback() {}
        function execInteractiveCallback() {}
        function execLoadedCallback() {}
        function execLoadingCallback() {}

        dojo.addOnLoad(function() {
            doh.run();
        });
	</script>
</head>
<body>

<!-- Callback parse tests -->
<script type="javascript/json" id="test_successful_callback_parse" data-js-type="request"
      data-success-code="loadCb"
      data-failure-code="errorCb"
      data-complete-code="function(request) {}"
      data-interactive-code="function(request) {}"
      data-loaded-code="function(request) {}"
      data-loading-code="function(request) {}">
</script>

<!-- Method parse tests -->
<script type="javascript/json" data-js-type="request" id="test_unsupported_callback_parse"
        data-unsupported-code="function() {}"></script>
<script type="javascript/json" data-js-type="request" id="test_method_default"></script>
<script type="javascript/json" data-js-type="request" id="test_method_with_data_attribute"
        data-method="put"></script>
<script type="javascript/json" data-js-type="request" id="test_method_with_method_attribute"
        method="post"></script>
<script type="javascript/json" data-js-type="request" id="test_method_with_data_and_method_attribute"
        method="put"
        data-method="delete"></script>

<!-- Argument parse tests -->
<script type="javascript/json" data-js-type="request" id="test_args_parse"
        data-url="/some/url"
        data-insertion="bottom"
        data-params="a=b&c=d"
        data-eval="true"
        data-sync="true">
</script>

<!-- Callback execution tests -->
<script type="javascript/json" id="test_callback_execution" data-js-type="request" method="post"
      data-success-code="execSuccessCallback"
      data-failure-code="execFailureCallback"
      data-complete-code="execCompleteCallback"
      data-interactive-code="execInteractiveCallback"
      data-loaded-code="execLoadedCallback"
      data-loading-code="execLoadingCallback">
</script>

</body>
</html>